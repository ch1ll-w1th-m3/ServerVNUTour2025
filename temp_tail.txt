            name="üèì **ƒê·ªô tr·ªÖ**",
            value=f"{round(bot.latency * 1000)}ms",
            inline=True
        )
        
        embed.add_field(
            name="üêç **Phi√™n b·∫£n**",
            value=f"discord.py {discord.__version__}",
            inline=True
        )
        
        embed.set_footer(text="VnuTourBot v1.0")
        await interaction.response.send_message(embed=embed)
    
    @bot.tree.command(name="clear", description="X√≥a tin nh·∫Øn (ch·ªâ admin)")
    @app_commands.describe(amount="S·ªë l∆∞·ª£ng tin nh·∫Øn c·∫ßn x√≥a")
    @app_commands.default_permissions(manage_messages=True)
    async def clear_slash(interaction: discord.Interaction, amount: int):
        """X√≥a tin nh·∫Øn (ch·ªâ admin)"""
        try:
            if amount < 1 or amount > 100:
                await interaction.response.send_message("‚ùå S·ªë l∆∞·ª£ng tin nh·∫Øn ph·∫£i t·ª´ 1 ƒë·∫øn 100")
                return
            
            # Defer response since this might take a while
            await interaction.response.defer(ephemeral=True)
            
            deleted = await interaction.channel.purge(limit=amount)
            await interaction.followup.send(f"üóëÔ∏è **ƒê√£ x√≥a {len(deleted)} tin nh·∫Øn**", ephemeral=True)
            
        except discord.Forbidden:
            await interaction.followup.send("‚ùå Bot kh√¥ng c√≥ quy·ªÅn x√≥a tin nh·∫Øn", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"‚ùå **L·ªói:** {str(e)}", ephemeral=True)
    
    # Assign Discord ID to participant by MSSV
    @bot.tree.command(name="assign", description="Li√™n k·∫øt Discord c·ªßa b·∫°n v·ªõi MSSV")
    @app_commands.describe(mssv="MSSV c·ªßa b·∫°n (trong Google Sheet)")
    async def assign_slash(interaction: discord.Interaction, mssv: str):
        try:
            mongo = getattr(bot, "mongo", None)
            if not mongo:
                await interaction.response.send_message("H·ªá th·ªëng c∆° s·ªü d·ªØ li·ªáu ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh.", ephemeral=True)
                return
            status, message = mongo.assign_discord_by_mssv(mssv, interaction.user.id)
            await interaction.response.send_message(message, ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"L·ªói: {e}", ephemeral=True)

    # Help Command
    @bot.tree.command(name="help", description="Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng bot")
    async def help_slash(interaction: discord.Interaction):
        """Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng bot"""
        embed = discord.Embed(
            title="ü§ñ **VnuTourBot - H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng**",
            description="Bot qu·∫£n l√Ω tour VNU v·ªõi c√°c ch·ª©c nƒÉng √¢m nh·∫°c v√† qu·∫£n l√Ω tr·∫°m",
            color=0x00ff00
        )
        
        # Music commands
        embed.add_field(
            name="üéµ **L·ªánh √¢m nh·∫°c**",
            value=(
                "`/play <t√™n/URL>` - Ph√°t nh·∫°c\n"
                "`/skip` - B·ªè qua b√†i h√°t hi·ªán t·∫°i\n"
                "`/queue` - Hi·ªÉn th·ªã queue nh·∫°c\n"
                "`/stop` - D·ª´ng ph√°t nh·∫°c\n"
                "`/volume <0-200>` - ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng"
            ),
            inline=False
        )
        
        # Admin commands
        embed.add_field(
            name="üîß **L·ªánh admin**",
            value=(
                "`/ping` - Ki·ªÉm tra ƒë·ªô tr·ªÖ\n"
                "`/info` - Th√¥ng tin bot\n"
                "`/clear <s·ªë>` - X√≥a tin nh·∫Øn"
            ),
            inline=False
        )
        
        embed.add_field(
            name="üí° **Ghi ch√∫**",
            value="S·ª≠ d·ª•ng `/` ƒë·ªÉ xem t·∫•t c·∫£ c√°c l·ªánh c√≥ s·∫µn",
            inline=False
        )
        
        embed.set_footer(text="VnuTourBot v1.0 - Slash Commands")
        await interaction.response.send_message(embed=embed)


# Helper functions (copied from music_commands.py)
async def apply_volume_from_current_position(vc: discord.VoiceClient, player, volume: float):
    """Apply volume immediately from current playback position"""
    try:
        # Get current track info
        track = player.now_playing
        if not track:
            return
        
        # Calculate current playback position
        current_time = 0
        if player.started_at:
            current_time = discord.utils.utcnow().timestamp() - player.started_at
        
        # Ensure current_time is not negative
        current_time = max(0, current_time)
        
        # Build FFmpeg options with seek to current position
        ffmpeg_opts = build_ffmpeg_options(track)
        
        # Add seek option to start from current position
        seek_option = f"-ss {current_time}"
        
        # Create new audio source with seek and volume
        source = discord.FFmpegPCMAudio(
            track.stream_url,
            before_options=f"{ffmpeg_opts} {seek_option}",
            options=f"-vn -af volume={volume}"
        )
        
        # Store new source
        player.current_source = source
        
        # Update start time to current position
        player.started_at = discord.utils.utcnow().timestamp() - current_time
        
        # Stop current playback first
        vc.stop()
        
        # Give more time for clean stop and cleanup
        await asyncio.sleep(0.1)
        
        # Cleanup old source if exists
        force_cleanup_ffmpeg_source(player.current_source)
        
        # Play with new volume from current position
        vc.play(source, after=lambda err: threading.Thread(target=lambda: asyncio.run(after_play_callback(err, player))).start())
        
    except Exception as e:
        print(f"[VOLUME POSITION ERROR] {e}")


async def play_next(guild, vc, player):
    """Play the next track in queue"""
    try:
        # Get next track
        track = player.get_next_track()
        if not track:
            return
        
        # Set as now playing
        player.now_playing = track
        player.started_at = discord.utils.utcnow().timestamp()
        
        # Build FFmpeg options
        ffmpeg_opts = build_ffmpeg_options(track)
        
        # Create audio source with current volume
        source = VolumeControlledAudioSource(
            track.stream_url,
            volume=player.volume,
            before_options=ffmpeg_opts,
            options="-vn"  # No volume filter needed, handled by our class
        )
        
        # Store source for cleanup
        player.current_source = source
        
        # Play audio with safe callback
        vc.play(source, after=lambda err: threading.Thread(target=lambda: asyncio.run(after_play_callback(err, player))).start())
        
        # Send now playing message with beautiful embed
        channel = guild.get_channel(player.text_channel_id)
        if channel:
            now_playing_embed = create_now_playing_embed(track)
            player.now_playing_msg = await channel.send(embed=now_playing_embed)
        
        # Create background task to handle track completion
        async def handle_track_completion():
            # Wait for completion
            await player.finished.wait()
            player.finished.clear()
            
            # When track finishes, update message to simple text
            if player.now_playing_msg:
                try:
                    await player.now_playing_msg.edit(content=f"‚úÖ **ƒê√£ ph√°t xong:** {track.title}", embed=None)
                except:
                    pass
            
            # Play next track if available
            if player.queue:
                await play_next(guild, vc, player)
            else:
                player.now_playing = None
                player.started_at = None
                player.now_playing_msg = None
        
        # Start background task (non-blocking)
        asyncio.create_task(handle_track_completion())
            
    except Exception as e:
        print(f"[PLAY NEXT ERROR] {e}")
        # Try to play next track
        if player.queue:
            await play_next(guild, vc, player)


def create_now_playing_embed(track):
    """Create a beautiful now playing embed"""
    embed = discord.Embed(
        title="üéµ **ƒêang ph√°t**",
        description=f"**{track.title}**",
        color=0x00ff00
    )
    
    # Add artist info if available
    if hasattr(track, 'artist') and track.artist:
        embed.add_field(
            name="üë§ **Ngh·ªá sƒ©**",
            value=track.artist,
            inline=True
        )
    
    # Add duration
    if hasattr(track, 'duration') and track.duration:
        duration_str = track.get_duration_str()
        embed.add_field(
            name="‚è±Ô∏è **Th·ªùi l∆∞·ª£ng**",
            value=duration_str,
            inline=True
        )
    
    # Add uploader if available
    if hasattr(track, 'uploader') and track.uploader:
        embed.add_field(
            name="üì∫ **K√™nh**",
            value=track.uploader,
            inline=True
        )
    
    # Add thumbnail if available
    if hasattr(track, 'thumbnail') and track.thumbnail:
        embed.set_thumbnail(url=track.thumbnail)
    
    embed.set_footer(text="üé∂ VnuTourBot Music Player")
    return embed
